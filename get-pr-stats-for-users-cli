#!/usr/local/bin/node

'use strict';

const {
    getRequests,
    simpleFlatten,
    getTicketStatus,
    slackPost
} = require('./helpers');

const meow = require('meow');

const cli = meow();

const JIRA_PASS = cli.flags.jiraPass;
const SLACK_BOT_SERVICE = cli.flags.slackBotService;
const STASH_HOST = cli.flags.stashHost;

const PROJECTS = cli.flags.projects.split(',');

function processArrayOfPrsAndConcat(arrayOfPrs) {
    return simpleFlatten(arrayOfPrs.map(({ values }) => values));
}

const reviewers = cli.flags.reviewers.split(',').reduce(function(newObject, singleReviewer) {
    return Object.assign(newObject, {
        [singleReviewer.trim()]: { reviewerPRCount: 0 }
    });
}, {});

function generateRequests(project) {
    return getRequests(JIRA_PASS, project, STASH_HOST);
}

function getTicket(singlePr) {
    return new Promise(resolve => {
        const ticketNumber = singlePr.fromRef.displayId.match(
            /AVPM-\d+|SELWEB-\d+|ROAD-\d+|ARCH-\d+/g
        );
        getTicketStatus(
            JIRA_PASS,
            ticketNumber ? ticketNumber[0] : '',
            STASH_HOST
        ).then(ticketData => {
            if (!ticketData) {
                resolve(Object.assign(singlePr, { ticketStatus: '' }));
                return;
            }
            const combinedStatuses = ticketData.reduce(
                (newStatuses, singleTicket) => {
                    return newStatuses.concat(singleTicket.fields.status.name);
                },
                []
            );

            resolve(
                Object.assign(singlePr, {
                    ticketStatus: combinedStatuses.join('/')
                })
            );
        });
    });
}

function getPullRequests() {
    return new Promise(resolve => {
        Promise.all(PROJECTS.map(generateRequests))
            .then(function(result) {
                resolve(result);
            })
            .catch(function(error) {
                console.log(error);
                resolve([]);
            });
    });
}

function getLink(newArray, currentObject) {
    return newArray.concat(
        `${currentObject.links.self[0].href} (${currentObject.ticketStatus})`
    );
}

getPullRequests().then(result => {
    const parsedResult = processArrayOfPrsAndConcat(result);
    Promise.all(parsedResult.map(getTicket)).then(wholeResult => {
        const recount = Object.keys(
            reviewers
        ).reduce((newObject, singleReviewer) => {
            const reviewCount = wholeResult.filter(singleReview => {
                return singleReview.reviewers.find(reviewer => {
                    return reviewer.user.name === singleReviewer;
                });
            });

            const authorCount = wholeResult.filter(singleReview => {
                return singleReview.author.user.name === singleReviewer;
            });

            const conflicts = authorCount
                .filter(singleReview => {
                    return singleReview.properties.mergeResult
                        ? singleReview.properties.mergeResult.outcome.trim() ===
                              'CONFLICTED'
                        : false;
                })
                .reduce(getLink, []);

            const needsWork = authorCount
                .filter(singleReview => {
                    return singleReview.reviewers.some(
                        ({ status }) => status === 'NEEDS_WORK'
                    );
                })
                .reduce(getLink, []);

            const fullyApproved = authorCount
                .filter(singleReview => {
                    return singleReview.reviewers.every(
                        ({ status }) => status === 'APPROVED'
                    );
                })
                .reduce(getLink, []);

            return Object.assign(reviewers, {
                [singleReviewer]: {
                    reviewerPRCount: reviewCount.length,
                    conflicts,
                    needsWork,
                    fullyApproved,
                    authorCount: authorCount.length
                }
            });
        }, reviewers);
        const sorted = Object.keys(recount)
            .reduce((newArray, singleReviewer) => {
                return newArray.concat({
                    name: singleReviewer,
                    fullyApproved: recount[singleReviewer].fullyApproved,
                    reviewerPRCount: recount[singleReviewer].reviewerPRCount,
                    conflicts: recount[singleReviewer].conflicts,
                    needsWork: recount[singleReviewer].needsWork,
                    authorCount: recount[singleReviewer].authorCount
                });
            }, [])
            .sort((a, b) => (a.reviewerPRCount <= b.reviewerPRCount ? -1 : 1));

        sorted.forEach(
            ({
                name,
                fullyApproved,
                reviewerPRCount,
                conflicts,
                needsWork,
                authorCount
            }) => {
                if (
                    !fullyApproved.length &&
                    !reviewerPRCount &&
                    !conflicts.legnth &&
                    !needsWork.length &&
                    !authorCount
                ) {
                    return '';
                }

                let newText = `\n===========\n *${name}* is author of ${authorCount} requests, and reviews ${reviewerPRCount} \n`;

                if (conflicts.length) {
                    newText += `\nConflicts: :fire:\n ${conflicts.join('\n')}`;
                }

                if (needsWork.length) {
                    newText += `\nNeeds Work: :wrench:\n ${needsWork.join('\n')}`;
                }

                if (fullyApproved.length) {
                    newText += `\nFully approved: :rocket:\n ${fullyApproved.join('\n')}`;
                }
                if (cli.flags.console) {
                    console.log(newText, `@${name}`);
                } else {
                    slackPost(newText, `@${name}`, SLACK_BOT_SERVICE).then(
                        console.log
                    );
                }
            },
            ''
        );
    });
});